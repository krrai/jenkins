#!/bin/env python
"""options/base.py - Base classes for DSL options and some utility functions
"""
from six import iteritems
from collections import Mapping

from jinja2.sandbox import SandboxedEnvironment

from stdci_libs.struct_normalizer import (
    normalize_value, scalar, DataNormalizationError, normalize_option,
    map_with, all_of
)


class ConfigurationSyntaxError(Exception):
    pass


def render_template(thread, template):
    """Render given iterable of templates in a sandboxed environment.

    :param JobThread thread:   JobThread instance the templates refer to
    :param template:           Template we need to render.

    :returns: Rendered template(s)
    """
    sandbox = SandboxedEnvironment()
    rendered = (
        sandbox.from_string(template).render(
            stage=thread.stage,
            substage=thread.substage,
            distro=thread.distro,
            arch=thread.arch
        )
    )
    if not isinstance(rendered, str):
        # Throw away unicode on Py2 since making it work properly is more
        # trouble then its worth
        rendered = rendered.encode('ascii', 'ignore')
    return rendered


def template_string(else_='Invalid value for template string'):
    """A normalization function generator for strings that are Jinja templates

    :param str else_: Optional error message to raise if value is not a string

    :rtype: function
    :returns: A function that accepts a JobThread and a value and converts the
              value to a string, or raises the given error message in a
              DataNormalizationError exception if that cannot be done. The
              string is then used as a Jinja2 template to generate the returned
              value.
    """
    def normalizer(thread, value):
        tmpl = normalize_value(thread, value, to=scalar(type=str, else_=else_))
        if tmpl:
            return render_template(thread, tmpl)
        else:
            raise DataNormalizationError(else_)
    return normalizer


def normalize_thread_options(thread, **kwargs):
    """A helper function for normalizing thread options

    :param JobThread thread: A thread object to normalize options for

    :rtype: JobThread
    :returns: A thread object where for each given kwarg, the option named by
              the key had been normalized with the normalizer function given
              by the value
    """
    for key, nrmfun in iteritems(kwargs):
        update_dict = normalize_option(thread, thread.options, key, to=nrmfun)
        if not update_dict:
            continue
        new_options = thread.options.copy()
        new_options.update(update_dict)
        thread = thread.with_modified(options=new_options)
    return thread


class DslLookupMap(Mapping):
    """Specialized pseudo-Mapping class for case-insensitive lookup

    The class wraps around a map yielded from the DSL parser (all keys are
    strings in lower case an without signs) and provides case insensitive
    lookup into it

    :param Mapping wrapped_map: The existing map to wrap around

    Since iteration and length calculation do not make sense when key
    insensitivity is in place (If 'Key', 'key' and 'KEY' all map to the same
    value, how many keys do we have in the Map?), trying to perform those
    operations on a wrapped map would raise a NotImplementedError
    """
    def __init__(self, wrapped_map):
        self._wrapped_map = wrapped_map

    def __getitem__(self, key):
        return self._wrapped_map[key.lower()]

    def __contains__(self, key):
        """We implement this to not rely on exceptions for implementing `in`
        """
        return key.lower() in self._wrapped_map

    def __iter__(self):
        raise NotImplementedError("Can't iterate")

    def __len__(self):
        raise NotImplementedError("Can't iterate")

    @classmethod
    def normalizer(cls, thread, value):
        """A normalizer function that wraps Mapping values with this class
        """
        if isinstance(value, Mapping):
            return cls(value)
        else:
            return value


def map_with_cased_keys(**options):
    """A version of the map_with function where the output can contain keys
    with uppercase characters while the input is expected to be all lowercase
    (as generated by the DSL parser)

    Arguments and return value are the same as for map_with, except for the
    relaxed key lookup rules
    """
    return all_of(DslLookupMap.normalizer, map_with(**options))
